"use client"

import { useState, useEffect } from 'react';
import Link from "next/link";
import { BsArrowLeft } from "react-icons/bs";
import { motion } from "framer-motion";
import ReactMarkdown from 'react-markdown';

const articleContent = `
# Compilers are Awesome: When Code Gets Lost in Translation

In the magical world of software development, there exists a powerful yet often underappreciated tool: the compiler. Like a master translator, it turns human-readable code into machine instructions that computers can execute. Let's embark on a journey to uncover why compilers are the unsung heroes of the programming universe and how they make our code come alive.

## 1. The Magic of Translation: Source Code to Machine Code

Imagine writing a novel in English and having it seamlessly translated into every language in the world. This is the kind of magic compilers perform every day. They take high-level programming languages like C++, Java, or Python and convert them into low-level machine code that your computer's CPU can understand.

Here's a simplified view of the compilation process:

| Stage           | Description                                         |
|-----------------|-----------------------------------------------------|
| Lexical Analysis| Breaking down the code into tokens                  |
| Syntax Analysis | Checking the code's structure against grammar rules |
| Semantic Analysis| Ensuring the code makes sense                      |
| Optimization    | Enhancing performance and efficiency                |
| Code Generation | Producing machine code                              |

*Table: The stages of the compilation process*

## 2. The Compilation Pipeline: From Source to Execution

Let's dive deeper into the compilation pipeline. Understanding these stages can give you a newfound appreciation for the complexity and elegance of compilers.

\`\`\`cpp
// Example C++ code
int main() {
    int a = 5;
    int b = 10;
    int sum = a + b;
    return sum;
}
\`\`\`

### Lexical Analysis

In this stage, the compiler breaks the source code into tokens. Tokens are the smallest units of meaning, such as keywords, identifiers, and operators.

### Syntax Analysis

Next, the compiler checks the code's syntax against the language's grammar rules. It ensures that the structure of the code is correct.

### Semantic Analysis

This stage verifies that the code makes sense logically. It checks for type errors, undeclared variables, and other semantic issues.

### Optimization

Compilers can optimize code to run faster and use fewer resources. This can involve reordering instructions, eliminating redundant code, and more.

### Code Generation

Finally, the compiler generates machine code that the CPU can execute. This is the binary code that runs on your computer.

## 3. The Optimizers: Making Code Faster and Smaller

One of the most impressive aspects of modern compilers is their ability to optimize code. Let's take a look at how compilers can transform even the simplest code for better performance.

\`\`\`cpp
// Original code
int add(int x, int y) {
    return x + y;
}
\`\`\`

An optimizing compiler might inline this function, eliminating the overhead of a function call:

\`\`\`cpp
// Optimized code
int main() {
    int a = 5;
    int b = 10;
    int sum = 5 + 10;
    return sum;
}
\`\`\`

These optimizations can make a significant difference in performance, especially in high-performance applications like gaming, scientific computing, and financial modeling.

## 4. The Ecosystem: Compilers and Tools

Compilers don't work alone. They are part of a rich ecosystem of tools that enhance the development process. These include:

- **Integrated Development Environments (IDEs):** Tools like Visual Studio and Eclipse integrate compilers with editors, debuggers, and other utilities.
- **Build Systems:** Tools like Make, CMake, and Gradle automate the compilation process, managing dependencies and build configurations.
- **Static Analyzers:** Tools that analyze code without executing it, finding potential bugs and performance issues.

## 5. Real-World Impact: Where Compilers Shine

Compilers play a crucial role in many real-world applications:

- **Operating Systems:** Compilers are used to build the kernels and drivers that power operating systems.
- **Games:** High-performance game engines rely on optimized code generated by compilers.
- **Scientific Computing:** Compilers help translate complex mathematical models into executable code.

## Conclusion: Compilers – The Unsung Heroes

In the intricate dance of software development, compilers are the silent partners that make everything possible. They transform our abstract ideas into tangible, executable programs, optimizing and enhancing along the way.

Whether you're writing a simple script or developing a complex application, the compiler is your steadfast companion, turning your code into reality. Embrace the power of compilers and marvel at the magic of translation.

Remember: In the world of programming, compilers don't just translate—they elevate, optimize, and bring our code to life. Happy coding!
`;


const WhyCpp = () => {
  const [readTime, setReadTime] = useState('');
  const [addedTime, setAddedTime] = useState('');

  useEffect(() => {
    // Calculate read time
    const wordCount = articleContent.split(/\s+/).length;
    const readTimeMinutes = Math.ceil(wordCount / 200); // Assuming 200 words per minute
    setReadTime(`${readTimeMinutes} min read`);


    const addedDate = new Date(); // Use the current date and time
    const now = new Date();
    const diffHours = Math.floor((now - addedDate) / (1000 * 60 * 60));
    setAddedTime(`${diffHours} hours ago`);
}, [articleContent]);


  return (
    <section className="min-h-[80vh] flex flex-col justify-center py-12 xl:py-0">
      <div className="container mx-auto">
        <motion.div 
          initial={{opacity: 0}}
          animate={{
              opacity: 1,
              transition: {delay: 1.8, duration: 0.35, ease: "easeIn"}
          }}
          className="flex flex-col gap-8"
        >
          {/* Back button */}
          <Link 
            href="/articles"
            className="flex items-center text-white hover:text-accent transition-all duration-300"
          >
            <BsArrowLeft className="mr-2" />
            Back to Articles
          </Link>

          {/* Article content */}
          <div className="text-white/80 space-y-6 pb-12">  {/* Added padding-bottom class */}
          <ReactMarkdown 
  components={{
    h1: ({node, ...props}) => (
      <>
        <h1 className="text-4xl font-bold text-accent my-4" {...props} />
        <div className="flex justify-between items-center mt-2 mb-6">
          <span className="text-white/60 text-sm">
            {readTime} · {addedTime}
          </span>
        </div>
      </>
    ),
    h2: ({node, ...props}) => <h2 className="text-3xl font-bold text-white my-3" {...props} />,
    p: ({node, ...props}) => <p className="my-2" {...props} />,
    table: ({node, ...props}) => <table className="border-collapse border border-white/20 my-4" {...props} />,
    th: ({node, ...props}) => <th className="border border-white/20 p-2" {...props} />,
    td: ({node, ...props}) => <td className="border border-white/20 p-2" {...props} />,
    code: ({node, inline, ...props}) => 
      inline ? (
          <code className="bg-gray-800 rounded px-1" {...props} />
      ) : (
          <code className="block bg-gray-800 p-4 rounded my-4" {...props} />
      ),
  }}
>
  {articleContent}
</ReactMarkdown>
          </div>
        </motion.div>
      </div>
    </section>
  );
};

export default WhyCpp;
